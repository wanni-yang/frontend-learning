### 几个问题

##### Q：什么情况下需要跨域
A：
   - 资源跳转： 超链接、重定向、表单提交
   - 资源嵌入： link、script、img、frame等dom标签，还有css样式中background:url()、@font-face()等文件外链
   - 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
##### Q：为什么会出现跨域问题？
A：出于浏览器的同源策略限制，浏览器会拒绝跨域请求。</br>
  *注：严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：*
  - 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；
  - 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；
  - 通常浏览器不允许跨域读操作（Cross-origin reads）。*
  > 同源策略限制的是
  > - Cookie、LocalStorage 和 IndexDB 无法读取
  > - DOM 和 Js对象无法获得
  > - AJAX 请求不能发送
##### Q：什么情况才算作跨域？
A：非同源请求，均为跨域。同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）

### 跨域访问

1. #### 使用代理
2. #### JSONP
  >  script标签并不受同源策略约束, 基于script 标签可做 jsonp 形式的访问, 可以通过第三方服务器生成动态的js代码来回调本地的js方法，
  而方法中的参数则由第三方服务器在后台获取，并以JSON的形式填充到JS方法当中. 即 JSON with Padding. 具体如下:
  <pre>
  生成script标签
  var script = document.createElement("script");
  script.type = 'text/javascript';
  script.src = "http://domainhost:8080/login?user=admin&callback=onBack";
  document.head.appendChild(script);
  
  执行回调函数
  function onBack(res){
    var res = JSON.stringify(res)
    //do something
  }
  通过ajax发起请求
  $.ajax({
    url:"http:domainhost:8080/login",
    type:'get',
    dataType:'jsonp',
    jsonpCallBack:'onBack',
    data:{}
  });
  得到服务端返回数据，返回传参给回调函数，立即执行回调函数
  后端代码nodejs
  var querystring = require('querystring');
  var http = require('http')
  var server = http.createServer();
  
  server.on('request', function(req,res){
    var params = qs.parse(req.url.split('?')[1]));
    var fn = params.callback;
    //jsonp返回设置
    res.writeHead(200,{'Content-Type':'text/javascript'});
    res.write(fn + '(' + JSON.stringify(params) + ')');
    res.end();
  })
  server.listen('8080');
  
  </pre>
3. #### postMessage> postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递.
> postMessage(data,origin)
> 参数说明data: 要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，
所以我们在传递参数的时候建议使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果.
> origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法
只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为'/'。

##### postMessage使用场景
- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递
<pre>
  父页面
  window.frames[0].postMessage('message', origin)
  子页面
  window.addEventListener('message',function(e){
      if(e.source!=window.parent) return;//判断消息源，若消息源不是父页面则退出
        //TODO ...
  });
  e的属性data, 表示父页面传递过来的message，source, 表示发送消息的窗口对象origin, 表示发送消息窗口的源(协议+主机+端口号)
</pre>
4. #### CORS跨域访问
> 浏览器不再一味禁止跨域访问, 而是检查目的站点的响应头域, 进而判断是否允许当前站点访问. 通常, 服务器使用以下的这些响应头域用来通知浏览器
|响应头|value
|-|-
|Access-Control-Allow-Origin|指定可以访问的域
|Access-Control-Allow-Credentials|指定是否允许浏览器发送cookie,请求网页中需xhr.withCredentials = true;
|Access-Control-Allow-Methods|指定可以访问的请求方法
|Access-Control-Allow-Headers|
|Access-Control-Expose-Headers|
|Access-Control-Max-Age|

5. #### document.domain
> 主域相同单子域不同的跨域，两个页面都通过js强制设置document.domain为基础主域，就实现了同域
<pre>
父窗口：(http://www.domain.com/a.html)
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
子窗口：(http://child.domain.com/b.html)
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>

</pre>

6. #### window.name
> 获取/设置窗口的名称。该属性也被用于作为 JSONP 的一个更安全的备选来提供跨域通信（cross-domain messaging）。当window.location变化，重新加载，其name属性依然可以保持不变。name值支持2MB
##### 适用单向数据请求   
<pre>
    - 在页面A中通过iframe加载其他域的页面B
    - 在页面B中将A需要的数据传至window.name
    - 当A页面iframe.onload之后，页面A修改iframe地址变为同域地址，就可以获取到iframe的window.name属性值
    *A页面window.name和iframe中的window.name相互独立
</pre>
 
7. #### location.hash
8. #### Access Control
9. #### flash URLLoder
10. #### WebSocket
