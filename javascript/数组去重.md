#### 数组去重的几种方法 

  [demo](http://jsrun.net/MbgKp/edit)
 
 - 最原始版本
 
   思路：两层循环，外层遍历原始数组array,内层遍历动态变化的去重后的数组filter_array
        内层循环时当array[i] === filter_array[j]时跳出循环体
        判断j是否等于filter_array.length,相等说明内层循环遍历了一遍没有在filter_array中找到和原始数组array[i]相同的元素
        将array[i]添加到filter_array中
        直到array遍历结束
- 优化内层循环

  思路:用filter_array.indexOf(array[i]) === -1代替内层循环

- 排序后去重

  思路：对array进行排序，第一个元素或者和相邻元素不同时添加到filter_array

 
- 加一个参数判断数组是否已经排序，如果排序就按照第三种方法处理，没有排序的情况按照第二种方法进行。


- underscore方法再加一个参数表示对每个元素进行处理的函数对一些重复的区别定义 比如大小写字母也表示重复

  
- ES5 array.filter()判断的条件遍历原数组，当前元素在原数组中的位置等于当前下标说明唯一

  filter方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
  array.filter(function(currentValue,index,arr), thisValue)
  thisValue	可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"
  
- 排序+filter
  
  思路 过滤条件为第一个元素或者当前元素不等于上一个元素

- ES6 Set
  
  <pre>
    - function set_unique(array){
      return [...new Set(array)]
    }
    - var set_unique_arraw = (a) => [...new Set(a)]
   </pre>
   
- ES6 Map

<pre>
      function map_unique(array){
        const seed = new Map();
        return array.filter((a) => !seed.has(a) && seed.set(a ,1))
      }
</pre>
  
